"use strict";
/* Support Node.js 6.x and 8.x */
if (typeof Symbol.asyncIterator === 'undefined') {
    Object.assign(Symbol, { asyncIterator: Symbol.for('Symbol.asyncIterator') });
}
const kState = Symbol('state');
function waitForChunk(stream) {
    return new Promise((resolve, reject) => {
        let cleanup;
        const onError = (err) => { cleanup(); reject(err); };
        const onReadable = () => { cleanup(); resolve(); };
        const onEnd = () => { cleanup(); resolve(); };
        cleanup = () => {
            stream.removeListener('error', onError);
            stream.removeListener('readable', onReadable);
            stream.removeListener('end', onEnd);
        };
        stream.addListener('error', onError);
        stream.addListener('readable', onReadable);
        stream.addListener('end', onEnd);
    });
}
class ChunkIterator {
    constructor(stream) {
        this[kState] = { kind: 'active', stream };
        stream.once('error', (error) => {
            this[kState] = { kind: 'errored', error };
        });
        stream.once('end', () => {
            this[kState] = { kind: 'ended' };
        });
    }
    next(value) {
        const state = this[kState];
        if (state.kind === 'ended') {
            return Promise.resolve({ done: true, value: null });
        }
        if (state.kind === 'errored') {
            return Promise.reject(state.error);
        }
        const data = state.stream.read();
        if (data === null) {
            return waitForChunk(state.stream).then(() => this.next());
        }
        return Promise.resolve({ done: false, value: data });
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
module.exports = function asyncChunks(stream) {
    return new ChunkIterator(stream);
};
