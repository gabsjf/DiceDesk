"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const semaphore_1 = require("@calebboyd/semaphore");
/**
 * A promise-based data structure which allows tasks to be performed concurrently and resolved serially.
 */
class PoolQueue {
    constructor(concurrency) {
        this.concurrency = concurrency;
        this.semaphore = new semaphore_1.Semaphore(this.concurrency);
        this.tail = Promise.resolve();
    }
    /**
     * Submit a task to be completed
     *
     * @param task - an asynchronous function which will be executed concurrently
     * @returns a Promise containing the completed work. While the task is executed concurrently, the returned Promise is fulfilled serially in the order it was submitted.
     */
    submit(work) {
        const prev = this.tail;
        return this.tail = this.semaphore.acquire()
            .then(work)
            .then(result => {
            this.semaphore.release();
            return prev.then(() => result);
        });
    }
    /**
     * Wait until the queue has at least one free worker.
     */
    poll() {
        return this.semaphore.acquire().then(() => this.semaphore.release());
    }
    /**
     * Wait until the queue has no more work to complete.
     */
    drain() {
        const tail = this.tail;
        return tail.then(() => {
            if (this.tail === tail) {
                return;
            }
            return this.drain();
        });
    }
}
exports.default = PoolQueue;
//# sourceMappingURL=index.js.map